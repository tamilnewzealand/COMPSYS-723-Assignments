module CruiseControlController:

constant PedalsMin : float;
constant SpeedMin : float;
constant SpeedMax : float;

input On;
input Off;
input Resume;
input Accel : float;
input Brake : float;
input Speed : float;

output CruiseState : integer;

% OFF-1 ON-2 STDBY-3 DIS-4
var state := 1 : integer in
	loop
		emit CruiseState(state);
		pause;
		trap T2 in
			% OFF STATE LOGIC
			if state = 1 then
				present On then
					state := 2; exit T2;
				end present;
			end if;
			% ON STATE LOGIC
			if state = 2 then
				present Off then state := 1 end;
				if ?Accel > PedalsMin then
					state := 4; exit T2;
				end if;
				if ?Speed < SpeedMin then
					state := 4; exit T2;
				end if;
				if ?Speed > SpeedMax then
					state := 4; exit T2;
				end if;
				if ?Brake > PedalsMin then
					state := 3; exit T2;
				end if;
				exit T2;
			end if;
			% STANDBY STATE LOGIC
			if state = 3 then
				present Off then
					state := 1; exit T2;
				end present;
				present Resume then
					if ?Accel > PedalsMin then
						state := 4; exit T2;
					end if;
					if ?Speed < SpeedMin then
						state := 4; exit T2;
					end if;
					if ?Speed > SpeedMax then
						state := 4; exit T2;
					end if;
					if (?Speed > SpeedMin) and (?Speed < SpeedMax) then
						state := 2; exit T2;
					end if;
				end present;
				exit T2;
			end if;
			% DISABLE STATE LOGIC
			if state = 4 then
				present Off then
					state := 1; exit T2;
				end present;
				if (?Accel < PedalsMin) and (?Speed > SpeedMin) and (?Speed < SpeedMax) then
					state := 2; exit T2;
				end if;
				exit T2;
			end if;
		end trap
	end loop
end var
end module

module CruiseSpeedManagement:

constant SpeedMini : float;
constant SpeedMaxi : float;
constant SpeedInc : float;
constant Zero : float;

input Set;
input QuickDecel;
input QuickAccel;
input Accel : float;
input CruiseState : integer;

output CruiseSpeed : float;
input Speed : float;

var CurrentSpeed := Zero : float in
	loop
		emit CruiseSpeed(CurrentSpeed);
		pause;
		trap T3 in
			% OFF STATE LOGIC
			if ?CruiseState = 1 then
				CurrentSpeed := Zero;
				exit T3;
			% ALL OTHER STATES
			else
				present Set then
					CurrentSpeed := ?Speed;
					exit T3;
				end present;
				present QuickAccel then
					if CurrentSpeed < SpeedMaxi then
						CurrentSpeed := CurrentSpeed + SpeedInc;
						exit T3;
					end if;
				end present;
				present QuickDecel then
					if CurrentSpeed > SpeedMini then
						CurrentSpeed := CurrentSpeed - SpeedInc;
						exit T3;
					end if;
				end present;
				% IF JUST SWITCHED TO ON STATE, LOAD CURRENT SPEED
				if ((?CruiseState = 2) and (pre(?CruiseState) = 1)) then
					CurrentSpeed := ?Speed;
					exit T3;
				end if;
				exit T3;
			end if;
		end trap
	end loop
end var
end module

module ThrottleManagement:

input Accel : float;
input CruiseSpeed : float;
input CruiseState : integer;
input CurrentSpeed : float;
output ThrottleCmd : float;

function regulateThrottle(integer, float, float) : float;

loop
	pause;
	trap T3 in
		% OFF STATE LOGIC
		if ?CruiseState = 0 then
			emit ThrottleCmd(?Accel);
			exit T3;
		% IF JUST SWITCHED TO ON STATE, LOAD CURRENT SPEED
		elsif ((?CruiseState = 0) and (pre(?CruiseState) = 1)) then
			emit ThrottleCmd(regulateThrottle(1, ?CruiseSpeed, ?CurrentSpeed));
			exit T3;
		% ALREADY IN ON STATE
		elsif ?CruiseState = 1 then
			emit ThrottleCmd(regulateThrottle(0, ?CruiseSpeed, ?CurrentSpeed));
			exit T3;
		% IN STANDBY OR DISABLE BYPASS CRUISECONTROL
		else
			emit ThrottleCmd(?Accel);
			exit T3;
		end if;
	end trap
end loop
end module